<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<title>Эмулятор полёта футбольного мяча</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 700px; margin: 1rem auto; }
  label { display: block; margin: 0.5rem 0 0.1rem; }
  input[type=range] { width: 100%; }
  canvas { border: 1px solid #333; background: #eef; display: block; margin: 1rem 0; }
  #output { font-weight: bold; }
</style>
</head>
<body>

<h1>Эмулятор полёта футбольного мяча</h1>

<label for="power">Сила удара (начальная скорость), м/с: <span id="power_val">25</span></label>
<input type="range" id="power" min="5" max="40" value="25" step="1">

<label for="angle">Угол удара, градусы: <span id="angle_val">45</span></label>
<input type="range" id="angle" min="5" max="85" value="45" step="1">

<label for="wind_speed">Скорость ветра, м/с: <span id="wind_speed_val">0</span></label>
<input type="range" id="wind_speed" min="0" max="20" value="0" step="0.5">

<label for="wind_dir">Направление ветра, градусы (откуда дует, 0 — слева): <span id="wind_dir_val">0</span></label>
<input type="range" id="wind_dir" min="0" max="360" value="0" step="1">

<button id="runBtn">Запустить симуляцию</button>

<canvas id="canvas" width="680" height="400"></canvas>

<div id="output"></div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const powerSlider = document.getElementById('power');
  const angleSlider = document.getElementById('angle');
  const windSpeedSlider = document.getElementById('wind_speed');
  const windDirSlider = document.getElementById('wind_dir');

  const powerVal = document.getElementById('power_val');
  const angleVal = document.getElementById('angle_val');
  const windSpeedVal = document.getElementById('wind_speed_val');
  const windDirVal = document.getElementById('wind_dir_val');

  const output = document.getElementById('output');
  const runBtn = document.getElementById('runBtn');

  // Обновляем подписи ползунков
  function updateLabels() {
    powerVal.textContent = powerSlider.value;
    angleVal.textContent = angleSlider.value;
    windSpeedVal.textContent = windSpeedSlider.value;
    windDirVal.textContent = windDirSlider.value;
  }
  powerSlider.oninput = angleSlider.oninput = windSpeedSlider.oninput = windDirSlider.oninput = updateLabels;
  updateLabels();

  // Физические константы и параметры мяча
  const g = 9.81;           // ускорение свободного падения, м/с^2
  const m = 0.43;           // масса мяча, кг
  const rho = 1.2;          // плотность воздуха, кг/м^3
  const Cd = 0.25;          // коэффициент сопротивления (приблизительно)
  const A = 0.038;          // площадь поперечного сечения мяча, м^2 (диаметр ~0.22 м)

  // Временной шаг интеграции, сек
  const dt = 0.01;

  function degToRad(deg) {
    return deg * Math.PI / 180;
  }

  // Очистка холста
  function clearCanvas() {
    ctx.fillStyle = '#eef';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  // Рисуем оси и сетку
  function drawAxes(maxX, maxY) {
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;

    // Ось X
    ctx.beginPath();
    ctx.moveTo(40, canvas.height - 40);
    ctx.lineTo(canvas.width - 10, canvas.height - 40);
    ctx.stroke();

    // Ось Y
    ctx.beginPath();
    ctx.moveTo(40, canvas.height - 40);
    ctx.lineTo(40, 10);
    ctx.stroke();

    // Сетка и подписи по X
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    const stepX = maxX / 10;
    for(let i=0; i<=10; i++) {
      let x = 40 + (canvas.width - 50)*i/10;
      ctx.beginPath();
      ctx.moveTo(x, canvas.height - 40);
      ctx.lineTo(x, canvas.height - 35);
      ctx.stroke();
      let label = (stepX*i).toFixed(1);
      ctx.fillText(label, x - 10, canvas.height - 20);
    }
    ctx.fillText('Дальность, м', canvas.width/2 - 30, canvas.height - 5);

    // Сетка и подписи по Y
    const stepY = maxY / 10;
    for(let i=0; i<=10; i++) {
      let y = canvas.height - 40 - (canvas.height - 50)*i/10;
      ctx.beginPath();
      ctx.moveTo(35, y);
      ctx.lineTo(40, y);
      ctx.stroke();
      let label = (stepY*i).toFixed(1);
      ctx.fillText(label, 5, y + 4);
    }
    ctx.fillText('Высота, м', 5, 15);
  }

  // Основная функция симуляции
  function simulate(params) {
    // Параметры входа
    const v0 = params.v0;                  // начальная скорость, м/с
    const angle = degToRad(params.angle); // угол, радианы
    const windSpeed = params.windSpeed;   // м/с
    const windDir = degToRad(params.windDir); // направление ветра (откуда дует), радианы

    // Начальные условия
    let pos = {x:0, y:0};
    let vel = {
      x: v0 * Math.cos(angle),
      y: v0 * Math.sin(angle)
    };

    // Вектор ветра (компоненты скорости)
    // Ветер дует из ветрового направления, значит вектор ветра противоположен
    let windVel = {
      x: -windSpeed * Math.cos(windDir),
      y: -windSpeed * Math.sin(windDir)
    };

    // Массив точек траектории
    const traj = [];
    traj.push({...pos});

    // Максимальные высота и дальность для масштабирования
    let maxX = 0;
    let maxY = 0;

    // Интегрируем движение до приземления y <= 0
    while (pos.y >= 0) {
      // Относительная скорость мяча относительно воздуха
      let relVel = {
        x: vel.x - windVel.x,
        y: vel.y - windVel.y
      };
      let relSpeed = Math.sqrt(relVel.x**2 + relVel.y**2);

      // Сила сопротивления воздуха: F = 0.5 * rho * Cd * A * v^2
      let Fd = 0.5 * rho * Cd * A * relSpeed * relSpeed;

      // Углы для силы сопротивления (против направления относительной скорости)
      let Fdx = -Fd * (relVel.x / relSpeed);
      let Fdy = -Fd * (relVel.y / relSpeed);

      // Ускорения
      let ax = Fdx / m;
      let ay = (Fdy / m) - g;

      // Обновляем скорость и позицию
      vel.x += ax * dt;
      vel.y += ay * dt;

      pos.x += vel.x * dt;
      pos.y += vel.y * dt;

      // Добавляем точку траектории
      traj.push({...pos});

      // Обновляем максимумы
      if (pos.x > maxX) maxX = pos.x;
      if (pos.y > maxY) maxY = pos.y;

      // Защита от бесконечного цикла (если траектория затянулась)
      if(traj.length > 10000) break;
    }

    return {traj, maxX, maxY};
  }

  // Функция рисования траектории
  function drawTrajectory(traj, maxX, maxY) {
    clearCanvas();
    drawAxes(maxX, maxY);

    ctx.strokeStyle = '#d22';
    ctx.lineWidth = 2;
    ctx.beginPath();

    for(let i=0; i<traj.length; i++) {
      // Масштабирование координат
      let x = 40 + (traj[i].x / maxX) * (canvas.width - 50);
      let y = canvas.height - 40 - (traj[i].y / maxY) * (canvas.height - 50);

      if(i === 0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // Отметка точки приземления
    let last = traj[traj.length - 1];
    let lx = 40 + (last.x / maxX) * (canvas.width - 50);
    let ly = canvas.height - 40;
    ctx.fillStyle = 'blue';
    ctx.beginPath();
    ctx.arc(lx, ly, 5, 0, 2*Math.PI);
    ctx.fill();
  }

  // Обработка кнопки "Запустить симуляцию"
  runBtn.onclick = () => {
    let params = {
      v0: parseFloat(powerSlider.value),
      angle: parseFloat(angleSlider.value),
      windSpeed: parseFloat(windSpeedSlider.value),
      windDir: parseFloat(windDirSlider.value)
    };

    const {traj, maxX, maxY} = simulate(params);
    drawTrajectory(traj, maxX, maxY);

    // Вывод результатов
    let range = traj[traj.length - 1].x.toFixed(2);
    let maxHeight = Math.max(...traj.map(p=>p.y)).toFixed(2);

    output.innerHTML = `Максимальная высота: <b>${maxHeight} м</b>, дальность полёта: <b>${range} м</b>`;
  };

  // Рисуем пустой холст с осями при загрузке
  clearCanvas();
  drawAxes(50, 25);

})();
</script>

</body>
</html>