<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<title>Путь ветки — Занимательная математика с ИИ</title>
<style>
  body { 
    font-family: Arial, sans-serif; 
    background: #d0f8f8; 
    text-align: center; 
    margin: 0; 
    padding: 0;
  }
  h1 { margin-top: 20px; color: #2E8B57; }
  p { max-width: 700px; margin: 10px auto; font-size: 1.1em; line-height: 1.5; }
  canvas { background: #d7fbf8; border: 0px solid #ccc; margin-top: 20px;  cursor: default; }
footer {
  background-color: #2a6d66;
  color: #fff;
  text-align: center;
  padding: 1em;
  margin-top: 2em;
  border-radius: 5px;
}

</style>
</head>
<body>

<!-- <p>
На Земле, как и в лесу, настоящая сила — не в разрушении, а в том, чтобы ветки могли срастаться и расти вместе. Даже если одна ветка сломана, её уроки продолжают жить в других, как семена, которые прорастают сквозь землю.
</p>-->

<canvas id="treeCanvas" width="800" height="600" onclick="startSITE()"></canvas>
<h1>Занимательная математика с ИИ</h1>
<!--  <footer>
    © 2025 Занимательная математика с ИИ
  </footer>-->

<script>

const canvas = document.getElementById('treeCanvas');
const ctx = canvas.getContext('2d');
let branches = [];

canvas.addEventListener('mouseenter', () => {
    canvas.style.cursor = 'pointer'; // Изменить курсор на "указатель"
  });

  canvas.addEventListener('mouseleave', () => {
    canvas.style.cursor = 'default'; // Вернуть исходный курсор
  });


// Класс ветки
class Branch {
    constructor(x, y, length, angle, depth, parent=null, merged=false) {
        this.x = x;
        this.y = y;
        this.length = 0; // будем анимировать рост
        this.maxLength = length;
        this.angle = angle;
        this.depth = depth;
        this.parent = parent;
        this.children = [];
        this.merged = merged;
        this.growthSpeed = 1 + Math.random() * 1.3;
    }
}

// Создание дерева рекурсивно
function createBranch(x, y, length, angle, depth, parent=null) {
    let merged = (depth === 2 && Math.random() < 0.5);
    let branch = new Branch(x, y, length, angle, depth, parent, merged);
    branches.push(branch);
    if (depth > 0) {
        let len = length * 0.7;
        if (merged) {
            branch.children.push(createBranch(x, y, len, angle + 3, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle - 7, depth-1, branch));
//            branch.children.push(createBranch(x, y, len, angle + 19, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle - 13, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle + 33, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle - 27, depth-1, branch));
//            branch.children.push(createBranch(x, y, len, angle + 73, depth-1, branch));
//            branch.children.push(createBranch(x, y, len, angle - 57, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle, depth-1, branch));
        } else {
//            branch.children.push(createBranch(x, y, len, angle + 15, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle - 8, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle + 73, depth-1, branch));
//            branch.children.push(createBranch(x, y, len, angle - 71, depth-1, branch));
//            branch.children.push(createBranch(x, y, len, angle + 73, depth-1, branch));
            branch.children.push(createBranch(x, y, len, angle - 31, depth-1, branch));
        }
    }
    return branch;
}

// Рисование ветки
function drawBranch(branch) {
    let rad = branch.angle * Math.PI / 180;
    let xEnd = branch.x + branch.length * Math.cos(rad);
    let yEnd = branch.y - branch.length * Math.sin(rad);

    ctx.lineWidth = Math.max(branch.depth, 1);
    ctx.strokeStyle = branch.merged ? '#FF8C00' : `rgb(${50 + branch.depth*15}, ${100 + branch.depth*10}, 50)`;
    ctx.beginPath();
    ctx.moveTo(branch.x, branch.y);
    ctx.lineTo(xEnd, yEnd);
    ctx.stroke();

    // Обновляем координаты для детей
    branch.children.forEach(child => {
        child.x = xEnd;
        child.y = yEnd;
    });
}

// Анимация роста
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let allGrown = true;
    branches.forEach(branch => {
        if (branch.length < branch.maxLength) {
            branch.length += branch.growthSpeed;
            if (branch.length > branch.maxLength) branch.length = branch.maxLength;
            allGrown = false;
        }
        drawBranch(branch);
    });
    if (!allGrown) requestAnimationFrame(animate);
}

// Подсветка при наведении
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    branches.forEach(branch => {
        let rad = branch.angle * Math.PI / 180;
        let xEnd = branch.x + branch.length * Math.cos(rad);
        let yEnd = branch.y - branch.length * Math.sin(rad);
        if (branch.merged && Math.hypot(mouseX - xEnd, mouseY - yEnd) < 8) {
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = branch.depth + 1;
            ctx.beginPath();
            ctx.moveTo(branch.x, branch.y);
            ctx.lineTo(xEnd, yEnd);
            ctx.stroke();
        }
    });
});

// Создание дерева и запуск анимации
createBranch(canvas.width/2, canvas.height - 450, 100, -90, 7);
animate();

function startSITE(){
 window.location.href = "epigraph.html"; 
}

</script>

</body>
</html>

